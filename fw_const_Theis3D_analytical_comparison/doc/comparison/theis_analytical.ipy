import numpy as np
import matplotlib.pyplot as plt

import pskf.tools.plot.plotfunctions as pf
from vtk.util.numpy_support import vtk_to_numpy


def w(u):
    """
    Compute well function approximation from Allen(1954) and Hastings(1955)
    between 0<u<1. Parameters taken from Srivastava(1998).

    TODO: Implement u>1 from same source.

    Srivastava, R., & Guzman-Guzman, A., Practical approximations of the
    well function, Ground Water, 36(5), 844–848 (1998).
    http://dx.doi.org/10.1111/j.1745-6584.1998.tb02203.x

    Parameters
    ----------
    u : float
        Argument of the well function \frac{r^2 S}{4 \delta z K t}.
        r: distance from the well
        S: storage coefficient
        \delta z: thickness of aquifer
        K: hydraulic conductivity
        t: time

    Returns
    ----------
    w: float
        Well function for input value u.
    """

    if u <= 1:
        # Parameters
        a0 = -0.57722

        a1 = 0.99999

        a2 = -0.24991

        a3 = 0.05519

        a4 = -0.00976

        a5 = 0.00108

        # Well function
        w = -(-np.log(u) + a0 + a1 * u + a2 * u * u + a3 * u * u * u +
              a4 * u * u * u * u + a5 * u * u * u * u * u)
    else:
        # Parameters
        b0 = 0.2677

        b1 = 8.63476

        b2 = 18.05902

        b3 = 8.57333

        b4 = 1

        c0 = 3.95850

        c1 = 21.09965

        c2 = 25.63296

        c3 = 9.57332

        c4 = 1

        # Well function
        w = -(1 / (u * np.exp(u)) * (
            b0 + b1 * u + b2 * u * u + b3 * u * u * u + b4 * u * u * u * u) /
              (c0 + c1 * u + c2 * u * u + c3 * u * u * u + c4 * u * u * u * u))

    return w


def h_theis(r, t, h0, Q, delz, K, S):
    """
    Compute the head around a pumping well according to the THEIS model.
    Source: SHEMAT-Book Clauser2003, section 2.6.1, p.57.

    Parameters
    ----------
    r : float
        Distance from well [m]

    t : float
        time [s]

    h0 : float
        Undisturbed head without influence of the pumping well in [m].

    Q : float
        Pumping rate of the well in [m3s-1]

    delz : float
        Thickness of aquifer in [m]

    K : float
       Hydraulic conductivity in [m1s-1]

    S : float
        Storage coefficient [-]

    Returns
    ----------
    h : float
        head at difference r from pumping well and time t. [m]
    """

    # Compute input for well function
    u = r**2 * S / (4 * delz * K * t)

    # Compute new head
    h = h0 - Q / (4 * np.pi * delz * K) * w(u)

    return h


# Input values from SHEMAT Book, Clauser 2003

# Pumping rate Q in [m3s-1]
Q = -0.001

# Thickness of aquifer in [m]
delz = 20

# Hydraulic conductivity in [m1s-1]
rhof = 1000.0
g = 9.81
k = 10**-12
mu = 1 * 10**-3

K = rhof * g * k / mu

# Storage coefficient [-]
phi = 0.1
alpha = 10**-8
beta = 5 * 10**-8
S = rhof * g * (alpha + phi * beta) * delz

# Distance from well [m]
r = 41.953126

# Time in [s]
t = 60 * 60 * 24 * 3.5


######wofür ist  # + 'result/' ???
# Head from vtk
vtk_reader = pf.my_vtk(
    '/home/mv897575/Schreibtisch/SHEMAT-Suite_Models/3DTheis_aktuelleVersion/fw_const_3DTheis_analytical_comparison/doc/comparison/',
    'Theis3D_final_bas.vtk', 'head')
h_vtk = pf.my_vtk_to_numpy(vtk_reader)
x = vtk_to_numpy(vtk_reader.GetOutput().GetXCoordinates())

# PUMPING RATE vs SHEMAT-Suite Neumann Boundary condition not clear...

Q = -0.0040  # Minimaler max der Differenzen
# Q = -0.0040205                  # Minimaler Mean der Differenzen
# Q = -0.00403
# Q = -0.001

# Factor 0.15625*20 (for the square meter)

h_ana = [h_theis(rx, t, 20, Q, delz, K, S) for rx in x]
u = [rx**2 * S / (4 * delz * K * t) for rx in x]

print("Q: %0.3f"%Q, "max error absolute: %0.10f"%np.max(np.abs(h_vtk[0, 1:,1] - h_ana[1:])),
      "mean error absolute: %0.10f"%np.mean(np.abs(h_vtk[0, 1:,1] - h_ana[1:])))

plt.plot(x[1:], h_vtk[0, 1:,1] - h_ana[1:], '-o')
plt.savefig('h_vtk-h_ana')
plt.show()

plt.plot(x, np.array(h_vtk[0, :, 1]), '-o')
plt.plot(x, np.array(h_ana))
plt.savefig('h_vtk and h_ana')
plt.show()

# Logarithmic difference to 20m
plt.plot(x, np.log10(20 - np.array(h_vtk[0, :, 1])), '-o')
plt.plot(x, np.log10(20 - np.array(h_ana)), '-o')
plt.savefig('log_difference_to_20m')
plt.show()

# Relative error
plt.plot(x[:], (h_vtk[0, 0:, 1] - h_ana[:]) / (20 - np.array(h_ana)), '-o')
plt.savefig('relativeError')
plt.show()
